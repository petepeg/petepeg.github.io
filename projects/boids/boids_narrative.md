# Boids Narrative

### *Briefly describe the artifact. What is it? When was it created?*
I started work on the Boids application early 2020 as a project of personal interest. Boids is flocking simulator that demonstrates emergent behavior from three simple rules. The rules are as follows, Separation: steer to avoid crowing local flock mates, Alignment: steer towards the average heading of local flock mates, Cohesion: steer to move towards the average position of local flock mates.

### *Justify the inclusion of the artifact in your ePortfolio. Why did you select this item? What specific components of the artifact showcase your skills and abilities in software development? How was the artifact improved?*

Boids is a classic Computer Science simulation that I was fascinated with as a teenager and I credit it with my interest in pursuing this field. So naturally making my own implementation of it was an exciting prospect. I wanted to challenge myself for this one and decided to clean room this project, as in I would not look at any other implementations of the simulation and only use the rules as a guide.

Despite the rules being simple, their implementation is not. I faced several challenges in my attempt, first is performance, the simulation has large groups of object classes that contain about a dozen properties. Each object has to iterate over the entire list one or more times for every frame drawn. Even if they only do this once, with around 100 boids that means 100*100 traversals of the master array. Then each one of those 100 has to perform a series of calculations and things can get bogged down pretty fast. So, this project has provided a great space for showing off optimizations and the critical thinking skills required to make them. The next challenge I faced was the various math involved, each boid is making a few moderately complex trigonometric calculations every frame. Knowing how to use these correctly proved a challenge. The challenge mostly came from translating pure math into computer science math. In trigonometry we have a grid where 0 is center and moving in the positive direction is right for the x axis and up for the y, in Computer Science 0 is top left, and down is positive for y, and this proved to be a consistent source of errors in my thinking. Being able to think in world space as well as local space is an important skill and requires some practice.

After getting a mostly working prototype the enhancements I made I focused on removing repeated code. In several sections I had code to re-normalize the heading of each boid. This was to make sure that the heading variable did not exceed 360 or go below 0. In previous versions this has caused some problems particularly when calculating averages. Despite 360 and 720 being functionally equivalent when discussing a heading, taking the average of the two does not yield the proper result. A method within the Boid class was made to handle normalizing the heading. I have one other section of repeated code that does a similar job that needs to be brought into its own method, it determines if it is shorter to turn left or right to right a particular heading. I use this twice and it should be brought into its own method for better maintainability and readability.

Later I realized that the way I was averaging the boids heading was a naïve solution. Initially I was just taking the mean of the heading in degrees, but this doesn’t work in many cases. Considering some simple examples, if you have two points close to each other say, 2, and 8 degrees, the mean would be 5 which is ok. Take another two points say 1 and 359 degrees and the mean calculates to 180, which is not at all correct. The solution is to convert the headings into vector components, then add the resulting vectors before converting back to degrees. By adding the component vectors we end up with the average heading and a summed magnitude, but since we are only concerned about heading in this simulation (magnitude is fixed) we can just take the summed vectors and convert it back to degrees.

The other major enhancements I made were towards performance. I have a CPU heavy function that does coordinate transformation. It contains two cosine and sine calls. I previously had it inside of a for loop so that it was being run possibly the maximum number of times per frame. I moved it out of the loop after the target had been determined thereby limiting it to one call per boid per frame, this is really the best that could be done.

Next, I changed the way local groups were being constructed. At first, I had used the built-in sprite collision system of PyGame, but this proved inadequate for a number of reasons. The major one being is that each rule needed its own detection distance to tune the system to show proper behavior. Without thinking about it much at the time I had than implemented a method for each rule that made its own array of the local group. This created a scenario where the master list of all boids was iterated over 3 times per frame by every boid. Then each local list would be iterated over once by every boid per frame. In the worst-case scenario where they were all bunched up, the list could be iterated over in its entirety tens of thousands of times. To improve performance, I made a single method for generating the local groups. In a single for loop a local list for each rule is generated for each boid. This limits iterating over the full list to just once per boid per frame. Upon making this change I was able to add 45 more boids to the screen without experiencing any noticeable slowdown.

### *Reflect on the process of enhancing and/or modifying the artifact. What did you learn as you were creating it and improving it? What challenges did you face?*

When I initially set out to improve the performance, I started by designing a very long and complicated chain of IF statements that would find the largest detection range generate an array and then subsequent smaller arrays would iterate off that array to minimize the number of full list traversals. This initially seemed like a great way to handle changing parameters and limit the number of full array operations. About one third of my way through that logic I realized that if I’m iterating over the whole list once, I can just perform all the needed operations at the same time. Not only would this be simpler logic, but it would also be more efficient. I learned I need to remember to focus on the most simple version of the problem, I need to break things down into the smallest of pieces and ask myself “what are your actually trying to do” and not “how are you going to do it”.

This project also helped me become a lot more comfortable with a lot of mathematics I had learned in the past but never really internalized. This project ended up using a lot of trigonometry and vector math and gave me a reason to explore and learn more about those topics. I got to find problems as I was coding than explore math to develop solutions and I ended up understanding the concepts on a more fundamental level as a result.

[Back](./boids)
